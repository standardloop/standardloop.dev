{"config":{"separator":"[\\s\\-_,:!=\\[\\]()\\\\\"`/]+|\\.(?!\\d)"},"items":[{"location":"","level":1,"title":"Intro","text":"<p>Hello!</p>","path":["Intro"],"tags":[]},{"location":"links/","level":1,"title":"Links","text":"<ul> <li>Medium: @standardloop</li> <li>GitHub: /standardloop</li> <li>YouTube: /StandardLoop</li> </ul>","path":["Links"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/","level":1,"title":"Creating a C Dylib on macOS","text":"","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#background","level":2,"title":"Background","text":"<p>A Dynamic Library <code>*.dylib</code> is a library that's loaded at runtime instead of at compile time. They contain generic, unmodifiable code intended to be reused by many applications.</p> <p>It is analogous to Windows <code>*.dll</code> file or a <code>*.so</code> file on Linux.</p>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#create-a-place-to-store-the-dylib-and-header-file","level":2,"title":"Create a place to store the dylib and header file","text":"<p>Every <code>dylib</code> file will need a corresponding header (<code>.h</code>) file.</p> <p>It is recommended to use <code>/usr/local/lib</code> for personal dylib files and then <code>/usr/local/include</code> for personal header files.</p> <p>I will make a directory there to group mine:</p> <pre><code>$ sudo mkdir -p /usr/local/lib/standardloop/      # my dylibs will be put here\n$ sudo mkdir -p /usr/local/include/standardloop/  # the corresponding header files will be placed here\n</code></pre>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#example-dylib","level":2,"title":"Example Dylib","text":"<p>I'll define a <code>dylib</code> with a simple function that will add two ints and return the sum.</p>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#header-file","level":3,"title":"Header file","text":"<pre><code>$ touch add.h\n</code></pre> <pre><code>#ifndef STANDARDLOOP_ADD_H\n#define STANDARDLOOP_ADD_H\n\n#define STANDARDLOOP_ADD_H_MAJOR_VERSION 0\n#define STANDARDLOOP_ADD_H_MINOR_VERSION 0\n#define STANDARDLOOP_ADD_H_PATCH_VERSION 1\n#define STANDARDLOOP_ADD_H_VERSION \"0.0.1\"\n\nint add(int, int);\n\n#endif\n</code></pre>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#c-file","level":3,"title":"C file","text":"<pre><code>$ touch add.c\n</code></pre> <pre><code>#include \"add.h\"\n\nint add(int x, int y)\n{\n    return x + y;\n}\n</code></pre>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#compiling-the-dynamic-library","level":3,"title":"Compiling the Dynamic Library","text":"<pre><code>$ gcc -Werror -Wextra -Wall -Wfree-nonheap-object \\\n    -std=c17 \\\n    add.c \\\n    -O3 \\\n    -dynamiclib \\\n    -current_version 0.0.1 \\\n    -compatibility_version 0.0.1 \\\n    -o libstandardloop-add.dylib\n</code></pre> <p>Notice the <code>-dynamiclib</code>, <code>current_version</code>, and <code>compatibility_version</code> flags.</p> <p>We can then use <code>otool</code> to inspect it:</p> <pre><code>$ otool -L libstandardloop-add.dylib\nlibstandardloop-add.dylib:\n        libstandardloop-add.dylib (compatibility version 0.0.1, current version 0.0.1)\n        /usr/lib/libSystem.B.dylib (compatibility version 1.0.0, current version 1351.0.0)\n</code></pre>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#moving-the-files","level":3,"title":"Moving the files","text":"<pre><code>$ sudo cp libstandardloop-add.dylib /usr/local/lib/standardloop/\n$ sudo cp add.h /usr/local/include/standardloop/\n</code></pre>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#example-programming-using-the-dylib","level":2,"title":"Example Programming using the dylib","text":"","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#c-file_1","level":3,"title":"C file","text":"<pre><code>#include &lt;stdlib.h&gt;\n#include &lt;stdio.h&gt;\n\n#include &lt;standardloop/add.h&gt;\n\nint main()\n{\n    printf(\"%d\\n\", add(1, 2));\n    return EXIT_SUCCESS;\n}\n</code></pre> <p>Notice the import üòé</p>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#compiling","level":3,"title":"Compiling","text":"<pre><code>$ gcc -Werror -Wextra -Wall -Wfree-nonheap-object \\\n    -std=c17 \\\n    main.c  \\\n    -L/usr/local/lib/standardloop \\\n    -lstandardloop-add \\\n    -o main\n</code></pre> <p>notice the <code>-L</code> and <code>-l</code> flags used.</p> <p><code>-L</code> tells the compiler where to look for libraries. <code>-l</code> tells the compiler what specific libraries to link.</p>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#running","level":3,"title":"Running","text":"<pre><code>$ DYLD_FALLBACK_LIBRARY_PATH=/usr/local/lib/standardloop/ ./main\n3\n</code></pre> <p>Here we need to define a <code>DYLD_FALLBACK_LIBRARY_PATH</code> to tell the macOS dynamic linker where to find the <code>dylib</code>.</p> <p>There is also <code>DYLD_LIBRARY_PATH</code>, but I don't recommend using this variable.</p> <p>If it is not set, you will get an error like this: <pre><code>$ ./main\ndyld[77613]: Library not loaded: libstandardloop-add.dylib\n...\n</code></pre></p> <p>I recommend adding this line to your <code>~/.zshenv</code>: <pre><code>export DYLD_FALLBACK_LIBRARY_PATH=\"/usr/local/lib/standardloop\"\n</code></pre></p> <p>So you don't have to worry about setting the variable when running the executable.</p>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#taskfile","level":2,"title":"Taskfile","text":"<p>Folder structure:</p> <pre><code>‚îú‚îÄ‚îÄ lib\n‚îÇ   ‚îú‚îÄ‚îÄ add.c\n‚îÇ   ‚îú‚îÄ‚îÄ add.h\n‚îÇ   ‚îî‚îÄ‚îÄ Taskfile.yml\n‚îú‚îÄ‚îÄ main.c\n‚îî‚îÄ‚îÄ Taskfile.yml\n</code></pre>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#compiling-and-moving-the-dylib-taskfile-in-the-lib-directory","level":3,"title":"Compiling and moving the dylib (Taskfile in the lib directory)","text":"<pre><code>---\nversion: '3'\n\nvars:\n  CC: gcc\n  CC_FLAGS: \"-Werror -Wextra -Wall -Wfree-nonheap-object -std=c17\"\n  DYLIB_NAME: add\n  DYLIB_NAME_FULL: \"libstandardloop-{{.DYLIB_NAME}}.dylib\"\n  DYLIB_PATH: /usr/local/lib/standardloop/\n  DYLIB_INCLUDE_PATH: /usr/local/include/standardloop/\n  DYLIB_VERSION: 0.0.1\n  SOURCE_FILES:\n    - add.c\n\ntasks:\n  default:\n    deps:\n      - move-files\n\n  build-release:\n    cmds:\n      - |\n        {{.CC}} {{.CC_FLAGS}} \\\n        {{range .SOURCE_FILES}} {{.}} {{end}} \\\n        -O3 \\\n        -dynamiclib \\\n        -current_version {{.DYLIB_VERSION}} \\\n        -compatibility_version {{.DYLIB_VERSION}} \\\n        -o {{.DYLIB_NAME_FULL}}\n    sources:\n      - |\n        {{range .SOURCE_FILES}} {{.}} {{end}}\n    generates:\n      - \"{{.DYLIB_NAME_FULL}}\"\n\n\n  move-files:\n    deps:\n      - build-release\n    cmds:\n      - sudo -v\n      - sudo cp {{.DYLIB_NAME_FULL}} {{.DYLIB_PATH}}\n      - sudo cp {{.DYLIB_NAME}}.h {{.DYLIB_INCLUDE_PATH}}\n    status:\n      - otool -L {{.DYLIB_PATH}}{{.DYLIB_NAME_FULL}} | head -n 2 | tail -n 1 | grep \"current version {{.DYLIB_VERSION}}\"\n      - cat {{.DYLIB_INCLUDE_PATH}}{{.DYLIB_NAME}}.h | grep \"STANDARDLOOP_{{.DYLIB_NAME | upper}}_H_VERSION \\\"{{.DYLIB_VERSION}}\\\"\"\n\n  clean:\n    allow_failure: true\n    cmds:\n      - sudo -v\n      - rm -f {{.DYLIB_NAME_FULL}}\n      - sudo rm -f {{.DYLIB_PATH}}{{.DYLIB_NAME_FULL}}\n      - sudo rm -f {{.DYLIB_INCLUDE_PATH}}{{.DYLIB_NAME}}.h\n</code></pre> <p>This file won't be run directly</p>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#compiling-our-test-program","level":3,"title":"Compiling our test Program","text":"<pre><code>---\nversion: '3'\n\nvars:\n  CC: gcc\n  CC_FLAGS: \"-Werror -Wextra -Wall -Wfree-nonheap-object -std=c17\"\n  EXECUTABLE_NAME: main\n  DYN_LIBS_USED_PATH: \"-L/usr/local/lib/standardloop\"\n  DYN_LIBS_USED: \"-lstandardloop-add\"\n  SOURCE_FILES:\n    - main.c\n\ntasks:\n  default:\n    deps:\n      - run\n\n  dependencies:\n    cmds:\n      - task --taskfile ./lib/Taskfile.yml\n\n  build:\n    deps:\n      - dependencies\n    cmds:\n      - |\n        {{.CC}} {{.CC_FLAGS}} \\\n        {{range .SOURCE_FILES}} {{.}} {{end}} \\\n        {{.DYN_LIBS_USED_PATH}} \\\n        {{.DYN_LIBS_USED}} \\\n        -o {{.EXECUTABLE_NAME}}\n    sources:\n      - |\n        {{range .SOURCE_FILES}} {{.}} {{end}}\n    generates:\n      - \"{{.EXECUTABLE_NAME}}\"\n\n  run:\n    deps:\n      - build\n    cmds:\n      - DYLD_FALLBACK_LIBRARY_PATH={{.DYLIB_PATH}} ./{{.EXECUTABLE_NAME}}\n    vars:\n      DYLIB_PATH: /usr/local/lib/standardloop/\n\n  clean:\n    allow_failure: true\n    cmds:\n      - rm -f {{.EXECUTABLE_NAME}}\n      - task --taskfile ./lib/Taskfile.yml clean\n</code></pre> <pre><code>$ task\ntask: [dependencies] task --taskfile ./lib/Taskfile.yml\ntask: [build-release] gcc -Werror -Wextra -Wall -Wfree-nonheap-object -std=c17 \\\n add.c  \\\n-O3 \\\n-dynamiclib \\\n-current_version 0.0.1 \\\n-compatibility_version 0.0.1 \\\n-o libstandardloop-add.dylib\n\ntask: [move-files] sudo -v\ntask: [move-files] sudo cp libstandardloop-add.dylib /usr/local/lib/standardloop/\ntask: [move-files] sudo cp add.h /usr/local/include/standardloop/\ntask: [build] gcc -Werror -Wextra -Wall -Wfree-nonheap-object -std=c17 \\\n main.c  \\\n-L/usr/local/lib/standardloop \\\n-lstandardloop-add \\\n-o main\n\ntask: [run] DYLD_FALLBACK_LIBRARY_PATH=/usr/local/lib/standardloop/ ./main\n3\n</code></pre>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/c/dylib-on-macos/#conclusion","level":2,"title":"Conclusion","text":"<p>This article is about creating your very own dynamic library for C on macOS. This is how you can import with angle brackets instead of quotes. We also looked at automating this whole demo with Taskfile.</p>","path":["Tech Articles","C","Creating a C Dylib on macOS"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/","level":1,"title":"Introduction to Local Kubernetes Using¬†Kind","text":"","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#github-repo","level":2,"title":"GitHub Repo","text":"<ul> <li>https://github.com/standardloop/knowledge-transfer/tree/main/01-kind</li> </ul>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#background","level":2,"title":"Background","text":"<p>kind is a tool for running local Kubernetes clusters using Docker container ‚Äúnodes‚Äù. kind was primarily designed for testing Kubernetes itself, but may be used for local development or CI.</p> <p>Kind is part of the Kubernetes Special Interest Groups (SIGS)</p> <p>Special Interest Groups in Kubernetes provide places for the community to focus development and discussion on a particular part of the project.</p> <p>You can find the Kind source code here: - https://github.com/kubernetes-sigs/kind</p> <p>and the documentation here: - https://kind.sigs.k8s.io/</p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#prerequisites","level":2,"title":"Prerequisites","text":"","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#general-knowledge","level":3,"title":"General Knowledge","text":"<ul> <li><code>docker</code></li> <li><code>brew</code> (or your preferred package manager)</li> <li>YAML</li> <li><code>helm</code></li> <li><code>kubectl</code></li> </ul>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#install-and-setup","level":3,"title":"Install and Setup","text":"","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#docker","level":4,"title":"Docker","text":"<p>Have <code>docker</code> installed and have a docker engine running.</p> <p>For this article, I will be using Rancher Desktop.</p> <p>You can install Rancher Desktop with <code>brew</code> like this:</p> <pre><code>$ brew install --cask rancher\n</code></pre> <p>You can check your <code>docker</code> version with the following command: <pre><code>$ docker --version\nDocker version 28.1.1-rd, build 4d7f01e\n</code></pre></p> <p>Make sure your <code>docker</code> engine is running. You can check if it is with the following command: <pre><code>$ docker info &gt; /dev/null 2&gt;&amp;1\n$ echo $?\n0  # if it isn't running you should see a 1\n</code></pre></p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#kind","level":4,"title":"<code>kind</code>","text":"<p>I recommend installing using a package manager such as <code>brew</code> for macOS:</p> <pre><code>$ brew install kind\n$ which kind\n/opt/homebrew/bin/kind\n$ kind --version\nkind version 0.30.0\n</code></pre>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#creating-a-cluster-with-a-yaml-config-file","level":2,"title":"Creating a cluster with a yaml config file","text":"<ul> <li>https://kind.sigs.k8s.io/docs/user/configuration/</li> </ul>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#background_1","level":3,"title":"Background","text":"<p>I will naming my cluster <code>slke-1</code> (standardloop kubernetes engine 1).</p> <p>You can create clusters without config files, but I always recommend getting in the habit of using them for repeatable behavior.</p> <p>There are two kinds of node types, <code>control-plane</code> and <code>worker</code>.</p> <p>A single <code>control-plane</code> node is always required.</p> <p>If you try to make one without, you will see an error message such as this.</p> <pre><code>ERROR: failed to create cluster: must have at least one control-plane node\n</code></pre>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#config","level":3,"title":"Config","text":"<p>Make sure to check the newest version, you can find the images here: - https://hub.docker.com/r/kindest/node/</p> <p>I will create a file named <code>kind-config.yaml</code> and place the following contents in it:</p> <p><pre><code>---\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nname: slke-1\nnodes:\n  - role: control-plane\n    image: kindest/node:v1.34.0\n  - role: worker\n    image: kindest/node:v1.34.0\n</code></pre> Here we are creating two nodes, one for the control-plane and one worker.</p> <pre><code>$ kind create cluster --config=./kind-config.yaml\n...\n</code></pre> <p>You can use a tool such as kubectx to ensure your context is set. <pre><code>$ kubectx\nkind-slke-1\n</code></pre> Notice how the name is prefixed with <code>kind-</code></p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#see-the-nodes-running","level":3,"title":"See the nodes running","text":"","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#use-docker-ps-to-see-the-nodes-running","level":4,"title":"Use <code>docker ps</code> to see the nodes running","text":"<pre><code>$ docker ps\nCONTAINER ID   IMAGE                  COMMAND                  CREATED         STATUS         PORTS                       NAMES\n4b59fab194e5   kindest/node:v1.34.0   \"/usr/local/bin/entr‚Ä¶\"   2 minutes ago   Up 2 minutes   127.0.0.1:57499-&gt;6443/tcp   slke-1-control-plane\nbdf56ba1fc15   kindest/node:v1.34.0   \"/usr/local/bin/entr‚Ä¶\"   2 minutes ago   Up 2 minutes                               slke-1-worker\n</code></pre>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#kubectl-get-nodes","level":4,"title":"<code>kubectl get nodes</code>","text":"<pre><code>$ kubectl get nodes\nNAME                   STATUS   ROLES           AGE   VERSION\nslke-1-control-plane   Ready    control-plane   15m   v1.34.0\nslke-1-worker          Ready    &lt;none&gt;          15m   v1.34.0\n</code></pre> <p>If it is bothering you that <code>ROLES</code> is empty for the <code>worker</code> node, you can run: <pre><code>$ kubectl label nodes slke-1-worker node-role.kubernetes.io/worker=\"\"\nnode/slke-1-worker labeled\n$ kubectl get nodes\nNAME                   STATUS   ROLES           AGE   VERSION\nslke-1-control-plane   Ready    control-plane   16m   v1.34.0\nslke-1-worker          Ready    worker          16m   v1.34.0\n</code></pre></p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#updating-the-cluster","level":3,"title":"Updating the Cluster","text":"<p>You cannot update a cluster after creation, so you will need to delete it and then recreate it if you are changing any config.</p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#setting-up-cloud-provider-kind","level":3,"title":"Setting up <code>cloud-provider-kind</code>","text":"<p><code>cloud-provider-kind</code> allows you to use a Kubernetes <code>Service</code> type LoadBalancer.</p> <p>The reason it is called <code>cloud-provider-kind</code> is because when you use a Kubernetes <code>Service</code> type <code>LoadBalancer</code> in a cloud environment, such as Google Kubernetes Engine, the Cloud Provider will setup some infrastructure behind the scenes to allow routing.</p> <p>Previously, you had to configure MetalLB (which was a more involved setup and had issues on macOS), or use Extra Port Mappings (which was a simple solution, but it felt more hacky and different from what would be used in a production environment).</p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#install","level":4,"title":"Install","text":"<pre><code>$ brew install cloud-provider-kind\n$ which cloud-provider-kind\n/opt/homebrew/bin/cloud-provider-kind\n</code></pre>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#run","level":4,"title":"Run","text":"<p>I recommend opening a separate terminal session for running this command to easily view the logs.</p> <p>According to the README of the repository, you will need to run with <code>sudo</code> <pre><code>$ sudo cloud-provider-kind\n</code></pre></p> <p>You can watch the log information when a Kubernetes <code>Service</code> type <code>LoadBalancer</code> is created or deleted.</p> <p>You can also view the docker container running:</p> <pre><code>$ docker ps\nCONTAINER ID   IMAGE                      COMMAND                  CREATED          STATUS          PORTS                                                                                                                                     NAMES\na411bd911a94   envoyproxy/envoy:v1.33.2   \"/docker-entrypoint.‚Ä¶\"   4 seconds ago    Up 3 seconds    0.0.0.0:32774-&gt;80/tcp, [::]:32774-&gt;80/tcp, 0.0.0.0:32775-&gt;443/tcp, [::]:32775-&gt;443/tcp, 0.0.0.0:32776-&gt;10000/tcp, [::]:32776-&gt;10000/tcp   kindccm-f53170ec34f3\n...\n</code></pre>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#deploying-ingress-nginx-as-our-loadbalancer","level":3,"title":"Deploying <code>ingress-nginx</code> as our <code>LoadBalancer</code>","text":"","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#creating-a-values-file","level":4,"title":"Creating a values file","text":"<p>I will create a file called <code>ingress-nginx.values.yaml</code> with the following contents:</p> <pre><code>controller:\n  service:\n    type: \"LoadBalancer\"\n</code></pre> <p>You can pass values as command line arguments, but I prefer values files as it helps with upgrading the release if needed.</p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#deploy-the-helm-chart","level":3,"title":"Deploy the helm chart","text":"<p>Make sure to use the latest chart version, for me it was <code>4.13.3</code>.</p> <pre><code>$ helm repo add ingress-nginx https://kubernetes.github.io/ingress-nginx\n$ helm repo update\n$ helm upgrade --install ingress-nginx ingress-nginx/ingress-nginx \\\n    --create-namespace \\\n    -n ingress-nginx \\\n    --values ingress-nginx.values.yaml \\\n    --version 4.13.3 \\\n    --wait\n</code></pre>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#confirm-installation","level":4,"title":"Confirm installation","text":"","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#check-namespace-pod-and-service","level":5,"title":"Check namespace, pod, and service","text":"<pre><code>$ kubectl get ns\nNAME                 STATUS   AGE\ndefault              Active   21m\ningress-nginx        Active   2m12s\nkube-node-lease      Active   21m\nkube-public          Active   21m\nkube-system          Active   21m\nlocal-path-storage   Active   21m\n$ kubectl get pods -n ingress-nginx\nNAME                                        READY   STATUS    RESTARTS   AGE\ningress-nginx-controller-6f6c964579-csllp   1/1     Running   0          2m27s\n$ kubectl get svc -n ingress-nginx\nkubectl get svc -n ingress-nginx\nNAME                                 TYPE           CLUSTER-IP     EXTERNAL-IP   PORT(S)                      AGE\ningress-nginx-controller             LoadBalancer   10.96.241.10   172.18.0.4    80:32725/TCP,443:30829/TCP   2m51s\ningress-nginx-controller-admission   ClusterIP      10.96.249.13   &lt;none&gt;        443/TCP                      2m51s\n</code></pre> <p>If your <code>EXTERNAL-IP</code> for the <code>ingress-nginx-controller</code> svc is showing <code>&lt;pending&gt;</code> make sure <code>cloud-provider-kind</code> is running and inspect the logs.</p> <p>Easy way to print out your IP address: <pre><code>$ kubectl get svc/ingress-nginx-controller -n ingress-nginx -o=jsonpath='{.status.loadBalancer.ingress[0].ip}'\n172.18.0.4\n</code></pre></p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#use-curl-to-hit-the-loadbalancer","level":5,"title":"Use <code>curl</code> to hit the <code>LoadBalancer</code>","text":"<pre><code>$ curl http://172.18.0.4\n&lt;html&gt;\n&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;\n&lt;body&gt;\n&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;\n&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <p>Awesome!</p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#configure-etchosts","level":3,"title":"Configure <code>/etc/hosts</code>","text":"<p>Using the IP address we got from: <pre><code>$ kubectl get svc/ingress-nginx-controller -n ingress-nginx -o=jsonpath='{.status.loadBalancer.ingress[0].ip}'\n</code></pre></p> <p>We can update <code>/etc/hosts</code> to have a nice looking URL.</p> <pre><code>$ sudo vim /etc/hosts\n...\n172.18.0.4      kind.local\n</code></pre> <p>Now you can go to http://kind.local</p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#deploy-a-sample-app-and-use-the-ingress-controller","level":3,"title":"Deploy a Sample App and use the Ingress Controller","text":"<p>I will be using the hashicorp http-echo server has my example app.</p> <p>Make sure to use the most up to date image, you can view the images here.</p> <p>I will create a file called <code>app.yaml</code> and add the following manifests in it:</p> <pre><code>---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: app\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: http-echo-deployment\n  namespace: app\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: http-echo\n  template:\n    metadata:\n      labels:\n        app: http-echo\n    spec:\n      containers:\n        - name: http-echo\n          image: hashicorp/http-echo:1.0.0\n          args: [\"-text\", \"Hello from Kubernetes!\", \"-listen\", \":8080\"]\n          ports:\n            - containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: http-echo-service\n  namespace: app\nspec:\n  selector:\n    app: http-echo\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: ClusterIP\n---\napiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: http-echo-service-ingress\n  namespace: app\nspec:\n  ingressClassName: nginx\n  rules:\n    - host: kind.local\n      http:\n        paths:\n          - path: /\n            pathType: ImplementationSpecific\n            backend:\n              service:\n                name: http-echo-service\n                port:\n                  number: 80\n</code></pre> <pre><code>$ kubectl apply -f app.yaml\nnamespace/app created\ndeployment.apps/http-echo-deployment created\nservice/http-echo-service created\ningress.networking.k8s.io/http-echo-service-ingress created\n</code></pre> <p>Go to http://kind.local and see the message!</p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#cleaning-up","level":3,"title":"Cleaning up","text":"<p>stop your <code>cloud-provider-kind</code> by Ctrl+C'ing the terminal or by looking the processes and stopping it.</p> <p>And then delete your cluster: <pre><code>$ kind delete cluster --name slke-1\n</code></pre></p>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/intro-to-kind/#tldr","level":2,"title":"TLDR","text":"<p>Use my provided <code>Taskfile.yml</code> and run it all yourself easily!</p> <ul> <li>https://github.com/standardloop/knowledge-transfer/blob/main/01-kind/Taskfile.yml</li> </ul> <pre><code>$ task\n</code></pre>","path":["Tech Articles","Kind","Introduction to Local Kubernetes Using Kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/","level":1,"title":"Kind with Gateway API using <code>cloud-provider-kind</code>","text":"","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#github-repo","level":2,"title":"GitHub Repo","text":"<ul> <li>https://github.com/standardloop/knowledge-transfer/tree/main/02-kind-gateway-api</li> </ul>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#background","level":2,"title":"Background","text":"<p>kind is a tool for running local Kubernetes clusters using Docker container ‚Äúnodes‚Äù. kind was primarily designed for testing Kubernetes itself, but may be used for local development or CI.</p> <p>Kind is part of the Kubernetes Special Interest Groups (SIGS)</p> <p>Special Interest Groups in Kubernetes provide places for the community to focus development and discussion on a particular part of the project.</p> <p>You can find the Kind source code here: - https://github.com/kubernetes-sigs/kind</p> <p>and the documentation here: - https://kind.sigs.k8s.io/</p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#prerequisites","level":2,"title":"Prerequisites","text":"","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#general-knowledge","level":3,"title":"General Knowledge","text":"<ul> <li><code>docker</code></li> <li><code>brew</code> (or your preferred package manager)</li> <li>YAML</li> <li><code>kubectl</code></li> </ul>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#install-and-setup","level":3,"title":"Install and Setup","text":"","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#docker","level":4,"title":"Docker","text":"<p>Have <code>docker</code> installed and have a docker engine running.</p> <p>For this article, I will be using Rancher Desktop.</p> <p>You can install Rancher Desktop with <code>brew</code> like this:</p> <pre><code>$ brew install --cask rancher\n</code></pre> <p>You can check your <code>docker</code> version with the following command: <pre><code>$ docker --version\nDocker version 28.1.1-rd, build 4d7f01e\n</code></pre></p> <p>Make sure your <code>docker</code> engine is running. You can check if it is with the following command: <pre><code>$ docker info &gt; /dev/null 2&gt;&amp;1\n$ echo $?\n0  # if it isn't running you should see a 1\n</code></pre></p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#kind","level":4,"title":"<code>kind</code>","text":"<p>I recommend installing using a package manager such as <code>brew</code> for macOS:</p> <pre><code>$ brew install kind\n$ which kind\n/opt/homebrew/bin/kind\n$ kind --version\nkind version 0.30.0\n</code></pre>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#creating-a-cluster-with-a-yaml-config-file","level":2,"title":"Creating a cluster with a yaml config file","text":"<ul> <li>https://kind.sigs.k8s.io/docs/user/configuration/</li> </ul>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#background_1","level":3,"title":"Background","text":"<p>I will naming my cluster <code>slke-1</code> (standardloop kubernetes engine 1).</p> <p>You can create clusters without config files, but I always recommend getting in the habit of using them for repeatable behavior.</p> <p>There are two kinds of node types, <code>control-plane</code> and <code>worker</code>.</p> <p>A single <code>control-plane</code> node is always required.</p> <p>If you try to make one without, you will see an error message such as this.</p> <pre><code>ERROR: failed to create cluster: must have at least one control-plane node\n</code></pre>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#config","level":3,"title":"Config","text":"<p>Make sure to check the newest version, you can find the images here: - https://hub.docker.com/r/kindest/node/</p> <p>I will create a file named <code>kind-config.yaml</code> and place the following contents in it:</p> <p><pre><code>---\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nname: slke-1\nnodes:\n  - role: control-plane\n    image: kindest/node:v1.34.0\n  - role: worker\n    image: kindest/node:v1.34.0\n</code></pre> Here we are creating two nodes, one for the control-plane and one worker.</p> <pre><code>$ kind create cluster --config=./kind-config.yaml\n...\n</code></pre> <p>You can use a tool such as kubectx to ensure your context is set. <pre><code>$ kubectx\nkind-slke-1\n</code></pre> Notice how the name is prefixed with <code>kind-</code></p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#see-the-nodes-running","level":3,"title":"See the nodes running","text":"","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#use-docker-ps-to-see-the-nodes-running","level":4,"title":"Use <code>docker ps</code> to see the nodes running","text":"<pre><code>$ docker ps\nCONTAINER ID   IMAGE                  COMMAND                  CREATED         STATUS         PORTS                       NAMES\n4b59fab194e5   kindest/node:v1.34.0   \"/usr/local/bin/entr‚Ä¶\"   2 minutes ago   Up 2 minutes   127.0.0.1:57499-&gt;6443/tcp   slke-1-control-plane\nbdf56ba1fc15   kindest/node:v1.34.0   \"/usr/local/bin/entr‚Ä¶\"   2 minutes ago   Up 2 minutes                               slke-1-worker\n</code></pre>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#kubectl-get-nodes","level":4,"title":"<code>kubectl get nodes</code>","text":"<pre><code>$ kubectl get nodes\nNAME                   STATUS   ROLES           AGE   VERSION\nslke-1-control-plane   Ready    control-plane   15m   v1.34.0\nslke-1-worker          Ready    &lt;none&gt;          15m   v1.34.0\n</code></pre> <p>If it is bothering you that <code>ROLES</code> is empty for the <code>worker</code> node, you can run: <pre><code>$ kubectl label nodes slke-1-worker node-role.kubernetes.io/worker=\"\"\nnode/slke-1-worker labeled\n$ kubectl get nodes\nNAME                   STATUS   ROLES           AGE   VERSION\nslke-1-control-plane   Ready    control-plane   16m   v1.34.0\nslke-1-worker          Ready    worker          16m   v1.34.0\n</code></pre></p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#updating-the-cluster","level":3,"title":"Updating the Cluster","text":"<p>You cannot update a cluster after creation, so you will need to delete it and then recreate it if you are changing any config.</p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#setting-up-cloud-provider-kind","level":3,"title":"Setting up <code>cloud-provider-kind</code>","text":"<p><code>cloud-provider-kind</code> allows you to use a Kubernetes Gateway resource and get an assignable IP address</p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#install","level":4,"title":"Install","text":"<pre><code>$ brew install cloud-provider-kind\n$ which cloud-provider-kind\n/opt/homebrew/bin/cloud-provider-kind\n</code></pre>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#run","level":4,"title":"Run","text":"<p>I recommend opening a separate terminal session for running this command to easily view the logs.</p> <p>According to the README of the repository, you will need to run with <code>sudo</code> <pre><code>$ sudo cloud-provider-kind --gateway-channel standard\n</code></pre></p> <p>Notice the flag I am passing in.</p> <p>You can watch the log information when a Kubernetes <code>Gateway</code> is created or deleted.</p> <p>You can also view the docker container running:</p> <pre><code>$ docker ps\nCONTAINER ID   IMAGE                      COMMAND                  CREATED          STATUS          PORTS                                                                                                                                     NAMES\na411bd911a94   envoyproxy/envoy:v1.33.2   \"/docker-entrypoint.‚Ä¶\"   4 seconds ago    Up 3 seconds    0.0.0.0:32774-&gt;80/tcp, [::]:32774-&gt;80/tcp, 0.0.0.0:32775-&gt;443/tcp, [::]:32775-&gt;443/tcp, 0.0.0.0:32776-&gt;10000/tcp, [::]:32776-&gt;10000/tcp   kindccm-f53170ec34f3\n...\n</code></pre> <p>You can now see a GatewayClass was created for us in the cluster:</p> <pre><code>$ kubectl get GatewayClass\nNAME                  CONTROLLER                            ACCEPTED   AGE\ncloud-provider-kind   kind.sigs.k8s.io/gateway-controller   True       5m1s\n</code></pre>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#deploying-the-gateway-resource","level":3,"title":"Deploying the Gateway Resource","text":"<p>I will create a file called <code>gateway.yaml</code> with the following contents:</p> <pre><code>---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: gateway\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: Gateway\nmetadata:\n  name: gateway\n  namespace: gateway\nspec:\n  gatewayClassName: cloud-provider-kind\n  listeners:\n    - name: http\n      protocol: HTTP\n      port: 80\n      hostname: \"kind.local\"\n      allowedRoutes:\n        namespaces:\n          from: All\n</code></pre> <p>Notice how the <code>gatewayClassName</code> references the <code>GatewayClass</code> that was created for us shown in the previous step.</p> <p>Deploy with the following:</p> <pre><code>$ kubectl apply -f gateway.yaml\n</code></pre> <p>If you see this message: <pre><code>error: resource mapping not found for name: \"gateway\" namespace: \"gateway\" from \"gateway.yaml\": no matches for kind \"Gateway\" in version \"gateway.networking.k8s.io/v1\"\nensure CRDs are installed first\n</code></pre></p> <p>Just run the apply command again, the <code>cloud-provider-kind</code> service may not have been running fully.</p> <p>Easy way to print out your IP address: <pre><code>$ kubectl get gateway/gateway -n gateway | awk '{print $3}' | awk NR==2\n172.18.0.4\n</code></pre></p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#use-curl-to-hit-the-gateway","level":5,"title":"Use <code>curl</code> to hit the <code>Gateway</code>","text":"<pre><code>$ curl http://172.18.0.4 -I\nHTTP/1.1 404 Not Found\ndate: Mon, 03 Nov 2025 07:11:01 GMT\nserver: envoy\ntransfer-encoding: chunked\n</code></pre> <p>Awesome!</p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#configure-etchosts","level":3,"title":"Configure <code>/etc/hosts</code>","text":"<p>Using the IP address we got from: <pre><code>$ kubectl get gateway/gateway -n gateway | awk '{print $3}' | awk NR==2\n</code></pre></p> <p>We can update <code>/etc/hosts</code> to have a nice looking URL.</p> <pre><code>$ sudo vim /etc/hosts\n...\n172.18.0.4      kind.local\n</code></pre> <p>Now you can go to http://kind.local</p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#deploy-a-sample-app-and-use-the-ingress-controller","level":3,"title":"Deploy a Sample App and use the Ingress Controller","text":"<p>I will be using the hashicorp http-echo server has my example app.</p> <p>Make sure to use the most up to date image, you can view the images here.</p> <p>I will create a file called <code>app.yaml</code> and add the following manifests in it:</p> <pre><code>---\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: app\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: http-echo-deployment\n  namespace: app\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: http-echo\n  template:\n    metadata:\n      labels:\n        app: http-echo\n    spec:\n      containers:\n        - name: http-echo\n          image: hashicorp/http-echo:1.0.0\n          args: [\"-text\", \"Hello from Kubernetes!\", \"-listen\", \":8080\"]\n          ports:\n            - containerPort: 8080\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: http-echo-service\n  namespace: app\nspec:\n  selector:\n    app: http-echo\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 8080\n  type: ClusterIP\n---\napiVersion: gateway.networking.k8s.io/v1\nkind: HTTPRoute\nmetadata:\n  name: http-echo-route\n  namespace: app\nspec:\n  parentRefs:\n    - name: gateway\n      namespace: gateway\n  hostnames:\n    - \"kind.local\"\n  rules:\n    - backendRefs:\n        - name: http-echo-service\n          port: 80\n</code></pre> <pre><code>$ kubectl apply -f app.yaml\nnamespace/app created\ndeployment.apps/http-echo-deployment created\nservice/http-echo-service created\nhttproute.gateway.networking.k8s.io/http-echo-route created\n</code></pre> <p>Go to http://kind.local and see the message!</p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#cleaning-up","level":3,"title":"Cleaning up","text":"<p>stop your <code>cloud-provider-kind</code> by Ctrl+C'ing the terminal or by looking the processes and stopping it.</p> <p>And then delete your cluster: <pre><code>$ kind delete cluster --name slke-1\n</code></pre></p>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/kind/kind-gateway-api/#tldr","level":2,"title":"TLDR","text":"<p>Use my provided <code>Taskfile.yml</code> and run it all yourself easily!</p> <ul> <li>https://github.com/standardloop/knowledge-transfer/blob/main/02-kind-gateway-api/Taskfile.yml</li> </ul> <pre><code>$ task\n</code></pre>","path":["Tech Articles","Kind","Kind with Gateway API using cloud-provider-kind"],"tags":[]},{"location":"tech-articles/taskfile/helm/","level":1,"title":"Deploying a Helm Chart with Taskfile","text":"","path":["Tech Articles","Taskfile","Deploying a Helm Chart with Taskfile"],"tags":[]},{"location":"tech-articles/taskfile/helm/#github","level":2,"title":"GitHub","text":"<ul> <li>https://github.com/standardloop/knowledge-transfer/tree/main/05-deploy-a-helm-chart-with-taskfile</li> </ul>","path":["Tech Articles","Taskfile","Deploying a Helm Chart with Taskfile"],"tags":[]},{"location":"tech-articles/taskfile/helm/#prerequisites","level":2,"title":"Prerequisites","text":"<ul> <li>https://medium.com/@standardloop/using-taskfile-to-create-multiple-kind-clusters-0d9e4f4ad6d0</li> </ul>","path":["Tech Articles","Taskfile","Deploying a Helm Chart with Taskfile"],"tags":[]},{"location":"tech-articles/taskfile/helm/#current-taskfile","level":2,"title":"Current Taskfile","text":"<pre><code>---\nversion: '3'\n\nvars:\n  CLUSTERS_FOLDER: clusters\n  CLUSTERS:\n    sh: find ./{{.CLUSTERS_FOLDER}} -maxdepth 1 -type f\n\ntasks:\n  default:\n    aliases: [all, make]\n    deps:\n      - cloud-provider-kind:run\n\n  rancher:run:\n    run: once\n    silent: true\n    cmds:\n      - rdctl start\n      - |\n        until docker info &gt; /dev/null 2&gt;&amp;1\n        do\n          echo \"waiting for docker to come up....\"\n          sleep 5\n        done\n        echo \"docker is ready!\"\n    status:\n      - rdctl list-settings &gt; /dev/null 2&gt;&amp;1\n      - docker info &gt; /dev/null 2&gt;&amp;1\n\n  rancher:clean:\n    prompt: Do you want to update quit Rancher Desktop?\n    cmds:\n      - rdctl shutdown\n\n  clusters:create:\n    run: once\n    deps:\n      - rancher:run\n    cmds:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          cluster_name=$(yq '.name' {{.}})\n          if ! kubectl cluster-info --context kind-${cluster_name} &gt; /dev/null 2&gt;&amp;1\n          then\n            kind create cluster --config={{.}}\n          else\n            echo \"$cluster_name already created\"\n          fi\n        {{end}}\n    status:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          cluster_name=$(yq '.name' {{.}})\n          kubectl cluster-info --context kind-${cluster_name}\n        {{end}}\n\n  clusters:clean:\n    silent: true\n    cmds:\n      - kind delete clusters --all\n\n  cloud-provider-kind:run:\n    run: once\n    deps:\n      - clusters:create\n    interactive: true\n    cmds:\n      - sudo -v\n      - bash -c 'nohup sudo cloud-provider-kind &gt;/dev/null 2&gt;&amp;1 &amp;'\n    status:\n      - pgrep sudo cloud-provider-kind\n\n  cloud-provider-kind:clean:\n    silent: true\n    interactive: true\n    cmds:\n      - |\n        if pgrep sudo cloud-provider-kind &gt; /dev/null 2&gt;&amp;1\n        then\n          sudo -v\n          sudo pkill cloud-provider-kind\n        else\n          echo \"cloud-provider-kind is not running\"\n        fi\n\n  cloud-provider-kind:restart:\n    interactive: true\n    cmds:\n      - task: clean-cloud-provider-kind\n      - task: run-cloud-provider-kind\n\n  clean:\n    aliases: [delete]\n    ignore_error: true\n    cmds:\n      - task: cloud-provider-kind:clean\n      - task: clusters:clean\n      - task: rancher:clean\n</code></pre>","path":["Tech Articles","Taskfile","Deploying a Helm Chart with Taskfile"],"tags":[]},{"location":"tech-articles/taskfile/helm/#deploy-a-helm-chart-example-metrics-server","level":2,"title":"Deploy a Helm Chart, example: metrics-server","text":"<p>Metrics Server is a really common application you will deploy to a cluster. It allows you to use the HPA and VPA resources</p> <p>First I will create a values file for the helm chart:</p> <pre><code>$ touch metrics-server.values.yaml\n</code></pre> <p>and I will place the following contents in it: <pre><code>---\nargs:\n  - --cert-dir=/tmp\n  - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname\n  - --kubelet-use-node-status-port\n  - --metric-resolution=15s\n  - --kubelet-insecure-tls\n</code></pre></p> <p>Then let's add some variables to the Taskfile <pre><code>vars:\n  METRICS_SERVER_NS: kube-system\n  METRICS_SERVER_VERSION: 3.13.0\n</code></pre> At the time of writing this article, <code>3.13.0</code> is the most recent chart, but always check the latest here.</p>","path":["Tech Articles","Taskfile","Deploying a Helm Chart with Taskfile"],"tags":[]},{"location":"tech-articles/taskfile/helm/#create-a-task-to-deploy","level":3,"title":"Create a Task to deploy","text":"<pre><code>  metrics-server:deploy:\n    silent: true\n    deps:\n      - cloud-provider-kind:run\n    cmds:\n      - |\n        helm repo add metrics-server https://kubernetes-sigs.github.io/metrics-server/\n        helm upgrade --install metrics-server metrics-server/metrics-server \\\n          -n {{.METRICS_SERVER_NS}} \\\n          --values metrics-server.values.yaml \\\n          --version {{.METRICS_SERVER_VERSION}} \\\n          --wait\n</code></pre> <p>And then running the task:</p> <pre><code>$ task metrics-server:deploy\ntask: Task \"clusters:create\" is up to date\ntask: Task \"cloud-provider-kind:run\" is up to date\n\"metrics-server\" already exists with the same configuration, skipping\nRelease \"metrics-server\" does not exist. Installing it now.\nNAME: metrics-server\nLAST DEPLOYED: Sun Nov  9 16:13:35 2025\nNAMESPACE: kube-system\nSTATUS: deployed\nREVISION: 1\nTEST SUITE: None\nNOTES:\n***********************************************************************\n* Metrics Server                                                      *\n***********************************************************************\n  Chart version: 3.13.0\n  App version:   0.8.0\n  Image tag:     registry.k8s.io/metrics-server/metrics-server:v0.8.0\n***********************************************************************\n</code></pre>","path":["Tech Articles","Taskfile","Deploying a Helm Chart with Taskfile"],"tags":[]},{"location":"tech-articles/taskfile/helm/#status","level":3,"title":"Status","text":"<p>There are 2 ways to do this. 1) use helm template and then kubectl diff</p> <pre><code>    status:\n      - |\n        helm template metrics-server metrics-server/metrics-server \\\n          -n {{.METRICS_SERVER_NS}} \\\n          --is-upgrade \\\n          --no-hooks \\\n          --values metrics-server.values.yaml \\\n          --version {{.METRICS_SERVER_VERSION}} | kubectl diff -f -\n</code></pre> <p>2) use the helm diff plugin</p> <p>You can install with the following: <pre><code>$ helm plugin install https://github.com/databus23/helm-diff\n</code></pre></p> <pre><code>    status:\n      - |\n        helm diff upgrade metrics-server metrics-server/metrics-server \\\n          -n {{.METRICS_SERVER_NS}} \\\n          --values metrics-server.values.yaml \\\n          --version {{.METRICS_SERVER_VERSION}}\n</code></pre> <p>Running the task again we see:</p> <pre><code>$ task metrics-server:deploy\ntask: Task \"clusters:create\" is up to date\ntask: Task \"cloud-provider-kind:run\" is up to date\ntask: Task \"metrics-server:deploy\" is up to date\n</code></pre>","path":["Tech Articles","Taskfile","Deploying a Helm Chart with Taskfile"],"tags":[]},{"location":"tech-articles/taskfile/helm/#clean-task","level":3,"title":"Clean task","text":"<pre><code>  metrics-server:clean:\n    cmds:\n      - helm uninstall metrics-server -n {{.METRICS_SERVER_NS}}\n</code></pre> <p>Really simple üòÄ</p>","path":["Tech Articles","Taskfile","Deploying a Helm Chart with Taskfile"],"tags":[]},{"location":"tech-articles/taskfile/helm/#the-full-taskfile","level":2,"title":"The Full Taskfile","text":"<pre><code>---\nversion: '3'\n\nvars:\n  CLUSTERS_FOLDER: clusters\n  CLUSTERS:\n    sh: find ./{{.CLUSTERS_FOLDER}} -maxdepth 1 -type f\n  METRICS_SERVER_NS: kube-system\n  METRICS_SERVER_VERSION: 3.13.0\n\ntasks:\n  default:\n    aliases: [all, make]\n    deps:\n      - metrics-server:deploy\n\n  rancher:run:\n    run: once\n    silent: true\n    cmds:\n      - rdctl start\n      - |\n        until docker info &gt; /dev/null 2&gt;&amp;1\n        do\n          echo \"waiting for docker to come up....\"\n          sleep 5\n        done\n        echo \"docker is ready!\"\n    status:\n      - rdctl list-settings &gt; /dev/null 2&gt;&amp;1\n      - docker info &gt; /dev/null 2&gt;&amp;1\n\n  rancher:clean:\n    prompt: Do you want to update quit Rancher Desktop?\n    cmds:\n      - rdctl shutdown\n\n  clusters:create:\n    run: once\n    deps:\n      - rancher:run\n    cmds:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          cluster_name=$(yq '.name' {{.}})\n          if ! kubectl cluster-info --context kind-${cluster_name} &gt; /dev/null 2&gt;&amp;1\n          then\n            kind create cluster --config={{.}}\n          else\n            echo \"$cluster_name already created\"\n          fi\n        {{end}}\n    status:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          cluster_name=$(yq '.name' {{.}})\n          kubectl cluster-info --context kind-${cluster_name}\n        {{end}}\n\n  clusters:clean:\n    silent: true\n    cmds:\n      - kind delete clusters --all\n\n  cloud-provider-kind:run:\n    run: once\n    deps:\n      - clusters:create\n    interactive: true\n    cmds:\n      - sudo -v\n      - bash -c 'nohup sudo cloud-provider-kind &gt;/dev/null 2&gt;&amp;1 &amp;'\n    status:\n      - pgrep sudo cloud-provider-kind\n\n  cloud-provider-kind:clean:\n    silent: true\n    interactive: true\n    cmds:\n      - |\n        if pgrep sudo cloud-provider-kind &gt; /dev/null 2&gt;&amp;1\n        then\n          sudo -v\n          sudo pkill cloud-provider-kind\n        else\n          echo \"cloud-provider-kind is not running\"\n        fi\n\n  cloud-provider-kind:restart:\n    interactive: true\n    cmds:\n      - task: clean-cloud-provider-kind\n      - task: run-cloud-provider-kind\n\n  metrics-server:deploy:\n    deps:\n      - cloud-provider-kind:run\n    cmds:\n      - |\n        helm repo add --force-update metrics-server https://kubernetes-sigs.github.io/metrics-server/\n        helm upgrade --install metrics-server metrics-server/metrics-server \\\n          -n {{.METRICS_SERVER_NS}} \\\n          --values metrics-server.values.yaml \\\n          --version {{.METRICS_SERVER_VERSION}} \\\n          --wait\n    status:\n      - |\n        helm template metrics-server metrics-server/metrics-server \\\n          -n {{.METRICS_SERVER_NS}} \\\n          --is-upgrade \\\n          --no-hooks \\\n          --values metrics-server.values.yaml \\\n          --version {{.METRICS_SERVER_VERSION}} | kubectl diff -f -\n    # status:\n    #   - |\n    #     helm diff upgrade metrics-server metrics-server/metrics-server \\\n    #       -n {{.METRICS_SERVER_NS}} \\\n    #       --values metrics-server.values.yaml \\\n    #       --version {{.METRICS_SERVER_VERSION}}\n\n  metrics-server:clean:\n    cmds:\n      - helm uninstall metrics-server -n {{.METRICS_SERVER_NS}}\n\n  clean:\n    aliases: [delete]\n    ignore_error: true\n    cmds:\n      - task: metrics-server:clean\n      - task: cloud-provider-kind:clean\n      - task: clusters:clean\n      - task: rancher:clean\n</code></pre>","path":["Tech Articles","Taskfile","Deploying a Helm Chart with Taskfile"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/","level":1,"title":"Creating Kind Clusters with go-task (Taskfile)","text":"","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/#github","level":2,"title":"GitHub","text":"<ul> <li>https://github.com/standardloop/knowledge-transfer/tree/main/04-create-kind-clusters-with-taskfile</li> </ul>","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/#prerequisites","level":2,"title":"Prerequisites","text":"<ul> <li>https://medium.com/@standardloop/using-taskfile-to-launch-docker-via-rancher-desktop-26cecd4007b6</li> </ul>","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/#current-taskfile","level":2,"title":"Current Taskfile","text":"<pre><code>---\nversion: '3'\n\ntasks:\n  default:\n    aliases: [all, make]\n    deps:\n      - rancher:run\n\n  rancher:run:\n    run: once\n    silent: true\n    cmds:\n      - rdctl start\n      - |\n        until docker info &gt; /dev/null 2&gt;&amp;1\n        do\n          echo \"waiting for docker to come up....\"\n          sleep 5\n        done\n        echo \"docker is ready!\"\n    status:\n      - rdctl list-settings &gt; /dev/null 2&gt;&amp;1\n      - docker info &gt; /dev/null 2&gt;&amp;1\n\n  rancher:clean:\n    cmds:\n      - rdctl shutdown\n\n  clean:\n    aliases: [delete]\n    ignore_error: true\n    cmds:\n      - task: rancher:clean\n</code></pre> <p>So running <code>task</code> should show the following:</p> <pre><code>$ task\n\nINFO[0000] About to launch /usr/bin/open -a /Applications/Rancher Desktop.app ...\nwaiting for docker to come up....\nwaiting for docker to come up....\nwaiting for docker to come up....\nwaiting for docker to come up....\nwaiting for docker to come up....\ndocker is ready!\n</code></pre>","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/#kind","level":2,"title":"Kind","text":"","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/#create-a-directory-to-store-clusters","level":3,"title":"Create a Directory to Store clusters","text":"<p>I'm going to config my Taskfile in a way to support deploying multiple clusters</p> <p>Let's create a folder, I will name it <code>clusters</code> where I will store a config file for each cluster I want to deploy.</p> <pre><code>$ mkdir clusters\n</code></pre> <p>I will then create my first cluster config file: <pre><code>$ touch clusters/slke-1.yaml\n</code></pre> and place the following contents into the file:</p> <pre><code>---\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nname: slke-1\nnodes:\n  - role: control-plane\n    image: kindest/node:v1.34.0\n  - role: worker\n    image: kindest/node:v1.34.0\n</code></pre>","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/#create-a-task-to-deploy-the-clusters","level":3,"title":"Create a Task to deploy the clusters","text":"","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/#dynamic-variable-for-finding-cluster-config-files","level":4,"title":"Dynamic Variable for Finding Cluster Config File(s)","text":"<p>Taskfile allows you to create variables for your tasks to reference.</p> <p>I will make one variable to reference the folder name and then another for all the cluster files within the folder.</p> <p>The <code>CLUSTERS</code> variable will be a dynamic variable where the value will be treated as a command and the output assigned.</p> <p>I will use <code>find</code> command to essentially list all the files in the clusters directory.</p> <p>I strongly recomned to use <code>find</code> instead of <code>ls</code>, which is a command you would normally use to list files in a directory.</p> <pre><code>vars:\n  CLUSTERS_FOLDER: clusters\n  CLUSTERS:\n    sh: find ./{{.CLUSTERS_FOLDER}} -maxdepth 1 -type f\n</code></pre> <p><code>-maxdepth 1</code> means <code>find</code> will only check one directory deep.</p> <p><code>-type f</code> means <code>find</code> will only search for files, and not directories.</p> <p>We can create a <code>test</code> task to just check if the variable is being set properly:</p> <pre><code>  test:\n    silent: true\n    cmds:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          echo \"{{.}}\"\n        {{end}}\n</code></pre> <p>So running <code>task test</code>, we should see the following:</p> <pre><code>$ task test\n./clusters/slke-1.yaml\n</code></pre> <p>I'm using templates for the loop, you can read more about it in the docs here.</p>","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/#task-to-deploy-the-clusters","level":4,"title":"Task to deploy the Clusters","text":"<p>Before creating the cluster, I will get the name of the cluster from the config file using yq.</p> <p>I will then use <code>kubectl cluster-info</code> to see if a cluster was already created with the same name.</p> <p>If it's not created then I will use <code>kind create cluster</code> to create the cluster with the config file path we got from or dynamic <code>CLUSTERS</code> variable.</p> <pre><code>  clusters:create:\n    run: once\n    silent: true\n    deps:\n      - rancher:run\n    cmds:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          cluster_name=$(yq '.name' {{.}})\n          if ! kubectl cluster-info --context kind-${cluster_name} &gt; /dev/null 2&gt;&amp;1\n          then\n            kind create cluster --config={{.}}\n          else\n            echo \"$cluster_name already created\"\n          fi\n        {{end}}\n</code></pre> <p>Running the task we can see the following:</p> <pre><code>$ task clusters:create\nCreating cluster \"slke-1\" ...\n ‚úì Ensuring node image (kindest/node:v1.34.0) üñº\n ‚úì Preparing nodes üì¶ üì¶\n ‚úì Writing configuration üìú\n ‚úì Starting control-plane üïπÔ∏è\n ‚úì Installing CNI üîå\n ‚úì Installing StorageClass üíæ\n ‚úì Joining worker nodes üöú\nSet kubectl context to \"kind-slke-1\"\nYou can now use your cluster with:\n\nkubectl cluster-info --context kind-slke-1\n\nHave a question, bug, or feature request? Let us know! https://kind.sigs.k8s.io/#community üôÇ\n</code></pre> <p>If we add another file to our clusters folder, example <code>slke-2.yaml</code> with the following contents: <pre><code>---\nkind: Cluster\napiVersion: kind.x-k8s.io/v1alpha4\nname: slke-2\nnodes:\n  - role: control-plane\n    image: kindest/node:v1.34.0\n  - role: worker\n    image: kindest/node:v1.34.0\n</code></pre></p> <p>We can run the task again to see the following:</p> <pre><code>$ task clusters:create\nslke-1 already created\nCreating cluster \"slke-2\" ...\n ‚úì Ensuring node image (kindest/node:v1.34.0) üñº\n ‚úì Preparing nodes üì¶ üì¶\n ‚úì Writing configuration üìú\n ‚úì Starting control-plane üïπÔ∏è\n ‚úì Installing CNI üîå\n ‚úì Installing StorageClass üíæ\n ‚úì Joining worker nodes üöú\nSet kubectl context to \"kind-slke-2\"\nYou can now use your cluster with:\n\nkubectl cluster-info --context kind-slke-2\n\nHave a nice day! üëã\n</code></pre> <p>Note: if you try to make too many clusters, you may get a cgroup error</p> <p>Now let's add a status:</p> <pre><code>  clusters:create:\n    run: once\n    deps:\n      - rancher:run\n    cmds:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          cluster_name=$(yq '.name' {{.}})\n          if ! kubectl cluster-info --context kind-${cluster_name} &gt; /dev/null 2&gt;&amp;1\n          then\n            kind create cluster --config={{.}}\n          else\n            echo \"$cluster_name already created\"\n          fi\n        {{end}}\n    status:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          cluster_name=$(yq '.name' {{.}})\n          kubectl cluster-info --context kind-${cluster_name}\n        {{end}}\n</code></pre> <p>The status will check all the clusters and ensure the cluster is reachable with <code>kubectl</code>.</p> <p>Running the task again we see the following:</p> <pre><code>$ task clusters:create\ntask: Task \"clusters:create\" is up to date\n</code></pre> <p>Finally let's add a clean task</p> <pre><code>  clusters:clean:\n    silent: true\n    cmds:\n      - kind delete clusters --all\n</code></pre> <p>This one is really simple because <code>kind</code> has a flag to delete all clusters.</p> <p>There is no need to loop through all our config for this one.</p> <p>Running it we see: <pre><code>$ task clusters:clean\nDeleted nodes: [\"slke-1-worker\" \"slke-1-control-plane\"]\nDeleted nodes: [\"slke-2-control-plane\" \"slke-2-worker\"]\nDeleted clusters: [\"slke-1\" \"slke-2\"]\n</code></pre></p> <p>If we didn't have any clusters and we ran it we will see this: <pre><code>$ task clusters:clean\nDeleted clusters: []\n</code></pre> So like I stated before there is no concern to loop through our config.</p>","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/#create-a-task-to-run-cloud-provider-kind","level":3,"title":"Create a Task to run <code>cloud-provider-kind</code>","text":"<p><code>cloud-provider-kind</code> allows you to use a Kubernetes Service type LoadBalancer.</p> <pre><code>  cloud-provider-kind:run:\n    run: once\n    deps:\n      - clusters:create\n    interactive: true\n    cmds:\n      - sudo -v\n      - bash -c 'nohup sudo cloud-provider-kind &gt;/dev/null 2&gt;&amp;1 &amp;'\n</code></pre> <p>since this command requires <code>sudo</code> access, I will first use <code>sudo -v</code> to all the user to pre-authorize sudo commands.</p> <p>I will then use <code>nohup</code> in combination  with <code>&amp;</code> so the program is spawned in the background.</p> <p>If you do not do this, to task is considered the parent of the program and when the task finishes it will remove it's children.</p> <p>If you ever need to undo <code>sudo -v</code> you can use <code>sudo -k</code></p> <p>Running the task we will see:</p> <pre><code>$ task cloud-provider-kind:run\ntask: Task \"clusters:create\" is up to date\ntask: [cloud-provider-kind:run] sudo -v\nPassword:\ntask: [cloud-provider-kind:run] bash -c 'nohup sudo cloud-provider-kind &gt;/dev/null 2&gt;&amp;1 &amp;'\n</code></pre> <p>You can then use <code>ps -A</code> to see the process running or use <code>pgrep</code></p> <p>Speaking of <code>pgrep</code> let's use it as our status checker:</p> <pre><code>    status:\n      - pgrep sudo cloud-provider-kind\n</code></pre> <p>So running the task again we will see: <pre><code>$ task cloud-provider-kind:run\ntask: Task \"clusters:create\" is up to date\ntask: Task \"cloud-provider-kind:run\" is up to date\n</code></pre></p> <p>For the clean task</p> <pre><code>  cloud-provider-kind:clean:\n    silent: true\n    interactive: true\n    cmds:\n      - |\n        if pgrep sudo cloud-provider-kind &gt; /dev/null 2&gt;&amp;1\n        then\n          sudo -v\n          sudo pkill cloud-provider-kind\n        else\n          echo \"cloud-provider-kind is not running\"\n        fi\n</code></pre> <p>Let's check if it is running, if it is then we will remove it.</p>","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/multicluster-kind/#the-whole-taskfile","level":2,"title":"The Whole Taskfile","text":"<pre><code>---\nversion: '3'\n\nvars:\n  CLUSTERS_FOLDER: clusters\n  CLUSTERS:\n    sh: find ./{{.CLUSTERS_FOLDER}} -maxdepth 1 -type f\n\ntasks:\n  default:\n    aliases: [all, make]\n    deps:\n      - cloud-provider-kind:run\n\n  test:\n    silent: true\n    cmds:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          echo \"{{.}}\"\n        {{end}}\n\n  rancher:run:\n    run: once\n    silent: true\n    cmds:\n      - rdctl start\n      - |\n        until docker info &gt; /dev/null 2&gt;&amp;1\n        do\n          echo \"waiting for docker to come up....\"\n          sleep 5\n        done\n        echo \"docker is ready!\"\n    status:\n      - rdctl list-settings &gt; /dev/null 2&gt;&amp;1\n      - docker info &gt; /dev/null 2&gt;&amp;1\n\n  rancher:clean:\n    prompt: Do you want to update quit Rancher Desktop?\n    cmds:\n      - rdctl shutdown\n\n  clusters:create:\n    run: once\n    deps:\n      - rancher:run\n    cmds:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          cluster_name=$(yq '.name' {{.}})\n          if ! kubectl cluster-info --context kind-${cluster_name} &gt; /dev/null 2&gt;&amp;1\n          then\n            kind create cluster --config={{.}}\n          else\n            echo \"$cluster_name already created\"\n          fi\n        {{end}}\n    status:\n      - |\n        {{range .CLUSTERS | splitArgs}}\n          cluster_name=$(yq '.name' {{.}})\n          kubectl cluster-info --context kind-${cluster_name}\n        {{end}}\n\n  clusters:clean:\n    silent: true\n    cmds:\n      - kind delete clusters --all\n\n  cloud-provider-kind:run:\n    run: once\n    deps:\n      - clusters:create\n    interactive: true\n    cmds:\n      - sudo -v\n      - bash -c 'nohup sudo cloud-provider-kind &gt;/dev/null 2&gt;&amp;1 &amp;'\n    status:\n      - pgrep sudo cloud-provider-kind\n\n  cloud-provider-kind:clean:\n    silent: true\n    interactive: true\n    cmds:\n      - |\n        if pgrep sudo cloud-provider-kind &gt; /dev/null 2&gt;&amp;1\n        then\n          sudo -v\n          sudo pkill cloud-provider-kind\n        else\n          echo \"cloud-provider-kind is not running\"\n        fi\n\n  cloud-provider-kind:restart:\n    interactive: true\n    cmds:\n      - task: clean-cloud-provider-kind\n      - task: run-cloud-provider-kind\n\n  clean:\n    aliases: [delete]\n    ignore_error: true\n    cmds:\n      - task: cloud-provider-kind:clean\n      - task: clusters:clean\n      - task: rancher:clean\n</code></pre>","path":["Tech Articles","Taskfile","Creating Kind Clusters with go-task (Taskfile)"],"tags":[]},{"location":"tech-articles/taskfile/rancher/","level":1,"title":"Using Taskfile (go-task) with Rancher","text":"","path":["Tech Articles","Taskfile","Using Taskfile (go-task) with Rancher"],"tags":[]},{"location":"tech-articles/taskfile/rancher/#github","level":2,"title":"GitHub","text":"<ul> <li>https://github.com/standardloop/knowledge-transfer/tree/main/03-running-rancher-with-go-task</li> </ul>","path":["Tech Articles","Taskfile","Using Taskfile (go-task) with Rancher"],"tags":[]},{"location":"tech-articles/taskfile/rancher/#install-and-setup","level":2,"title":"Install and Setup","text":"","path":["Tech Articles","Taskfile","Using Taskfile (go-task) with Rancher"],"tags":[]},{"location":"tech-articles/taskfile/rancher/#rancher","level":3,"title":"Rancher","text":"<p>Rancher Desktop is an app that provides container management and Kubernetes on the desktop. It is available for Mac (both on Intel and Apple Silicon), Windows, and Linux.</p> <p>For this article, I will be using Rancher Desktop.</p> <p>You can install Rancher Desktop with <code>brew</code> like this:</p> <pre><code>$ brew install --cask rancher\n</code></pre> <p>For other installation methods you can read the docs here.</p>","path":["Tech Articles","Taskfile","Using Taskfile (go-task) with Rancher"],"tags":[]},{"location":"tech-articles/taskfile/rancher/#go-task-taskfile","level":3,"title":"go-task (Taskfile)","text":"<p>go-task is a task runner / build tool that aims to be simpler and easier to use than, for example, GNU Make.</p> <p><code>task</code> uses <code>yaml</code> syntax.</p> <p>You can install task with <code>brew</code> like this:</p> <pre><code>$ brew install go-task\n$ which task\n/opt/homebrew/bin/task\n</code></pre> <p>For more install options you can view the docs here.</p>","path":["Tech Articles","Taskfile","Using Taskfile (go-task) with Rancher"],"tags":[]},{"location":"tech-articles/taskfile/rancher/#getting-started","level":2,"title":"Getting started","text":"<p>To generate a quick boilerplate taskfile you can run the following:</p> <pre><code>$ task --init\nTaskfile created: Taskfile.yml\n</code></pre> <p>You can then run the taskfile like this:</p> <pre><code>$ task\nHello, World!\n</code></pre>","path":["Tech Articles","Taskfile","Using Taskfile (go-task) with Rancher"],"tags":[]},{"location":"tech-articles/taskfile/rancher/#create-a-task-to-launch-rancher","level":3,"title":"Create a task to launch Rancher","text":"<pre><code>---\nversion: '3'\n\ntasks:\n  default:\n    deps:\n      - run-rancher\n\n  run-rancher:\n    run: once\n    cmds:\n      - rdctl start\n</code></pre> <p>This task can be run with:</p> <pre><code>$ task run-rancher\n</code></pre> <p>The problem is though, <code>rdctl start</code> will launch the app, but we do not know if the docker engine has started enough to use it</p> <p>/ add photo here /</p> <p>So after starting rancher let's add a loop to wait until docker is ready.</p> <pre><code>---\nversion: '3'\n\ntasks:\n  default:\n    deps:\n      - run-rancher\n\n  run-rancher:\n    run: once\n    cmds:\n      - rdctl start\n      - |\n        until docker info &gt; /dev/null 2&gt;&amp;1\n        do\n          echo \"waiting for docker to come up....\"\n          sleep 5\n        done\n        echo \"docker is ready!\"\n</code></pre> <p>We can use <code>until</code> here to check <code>docker info</code> until it is up and ready.</p> <p>Running the task we will see something like this: <pre><code>$ task\nINFO[0000] About to launch /usr/bin/open -a /Applications/Rancher Desktop.app ...\nwaiting for docker to come up....\nwaiting for docker to come up....\nwaiting for docker to come up....\nwaiting for docker to come up....\nwaiting for docker to come up....\ndocker is ready!\n</code></pre></p> <p>task has a status feature where it won't re-run a task if a condition is true.</p> <p>For us, we don't want to re-launch rancher if we know docker is running and the rancher cli is able to view it's own settings. Really only the former matters, but I will add both.</p> <p>The taskfile should now look like this:</p> <pre><code>---\nversion: '3'\n\ntasks:\n  default:\n    deps:\n      - run-rancher\n\n  run-rancher:\n    run: once\n    cmds:\n      - rdctl start\n      - |\n        until docker info &gt; /dev/null 2&gt;&amp;1\n        do\n          echo \"waiting for docker to come up....\"\n          sleep 5\n        done\n        echo \"docker is ready!\"\n    status:\n      - rdctl list-settings &gt; /dev/null 2&gt;&amp;1\n      - docker info &gt; /dev/null 2&gt;&amp;1\n</code></pre> <p>Now when we one <code>task</code> again we will see the following:</p> <pre><code>$ task\ntask: Task \"run-rancher\" is up to date\n</code></pre>","path":["Tech Articles","Taskfile","Using Taskfile (go-task) with Rancher"],"tags":[]},{"location":"tech-articles/taskfile/rancher/#create-a-task-to-stop-rancher","level":3,"title":"Create a task to stop Rancher","text":"<p>In addition to <code>rdctl</code> having a start command, it also as a stop command which is <code>rdctl shutdown</code>.</p> <p>Let's add a clean task using this:</p> <pre><code>  clean-rancher:\n    cmds:\n      - rdctl shutdown\n</code></pre> <p>Running <code>task clean-rancher</code> should show the following: <pre><code>$ task clean-rancher\ntask: [clean-rancher] rdctl shutdown\nShutting down.\n</code></pre></p> <p>Similar to the default task I made, I like to make a clean task:</p> <pre><code>  clean:\n    aliases: [delete]\n    ignore_error: true\n    cmds:\n      - task: clean-rancher\n</code></pre> <p>Now you can run <code>task clean</code> or <code>task delete</code></p>","path":["Tech Articles","Taskfile","Using Taskfile (go-task) with Rancher"],"tags":[]},{"location":"tech-articles/taskfile/rancher/#the-full-taskfile","level":2,"title":"The full Taskfile","text":"<pre><code>---\nversion: '3'\n\ntasks:\n  default:\n    aliases: [all, make]\n    deps:\n      - run-rancher\n\n  run-rancher:\n    run: once\n    cmds:\n      - rdctl start\n      - |\n        until docker info &gt; /dev/null 2&gt;&amp;1\n        do\n          echo \"waiting for docker to come up....\"\n          sleep 5\n        done\n        echo \"docker is ready!\"\n    status:\n      - rdctl list-settings &gt; /dev/null 2&gt;&amp;1\n      - docker info &gt; /dev/null 2&gt;&amp;1\n\n  clean-rancher:\n    cmds:\n      - rdctl shutdown\n\n  clean:\n    aliases: [delete]\n    ignore_error: true\n    cmds:\n      - task: clean-rancher\n</code></pre>","path":["Tech Articles","Taskfile","Using Taskfile (go-task) with Rancher"],"tags":[]}]}